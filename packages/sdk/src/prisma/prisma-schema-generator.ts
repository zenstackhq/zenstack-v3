import { lowerCaseFirst } from '@zenstackhq/common-helpers';
import { ZModelCodeGenerator } from '@zenstackhq/language';
import {
    AttributeArg,
    BooleanLiteral,
    ConfigArrayExpr,
    ConfigExpr,
    ConfigInvocationArg,
    DataField,
    DataFieldAttribute,
    DataFieldType,
    DataModel,
    DataModelAttribute,
    DataSource,
    Enum,
    EnumField,
    Expression,
    GeneratorDecl,
    InvocationExpr,
    isArrayExpr,
    isDataModel,
    isDataSource,
    isGeneratorDecl,
    isInvocationExpr,
    isLiteralExpr,
    isNullExpr,
    isReferenceExpr,
    isStringLiteral,
    isTypeDef,
    LiteralExpr,
    Model,
    NumberLiteral,
    StringLiteral,
} from '@zenstackhq/language/ast';
import {
    getAllAttributes,
    getAllFields,
    getStringLiteral,
    isAuthInvocation,
    isDelegateModel,
} from '@zenstackhq/language/utils';
import { AstUtils } from 'langium';
import { match } from 'ts-pattern';
import { ModelUtils } from '..';
import { DELEGATE_AUX_RELATION_PREFIX, getIdFields } from '../model-utils';
import {
    AttributeArgValue,
    ModelFieldType,
    AttributeArg as PrismaAttributeArg,
    AttributeArgValue as PrismaAttributeArgValue,
    ContainerDeclaration as PrismaContainerDeclaration,
    Model as PrismaDataModel,
    Enum as PrismaEnum,
    FieldAttribute as PrismaFieldAttribute,
    FieldReference as PrismaFieldReference,
    FieldReferenceArg as PrismaFieldReferenceArg,
    FunctionCall as PrismaFunctionCall,
    FunctionCallArg as PrismaFunctionCallArg,
    PrismaModel,
    ContainerAttribute as PrismaModelAttribute,
    type SimpleField,
} from './prisma-builder';

// Some database providers like postgres and mysql have default limit to the length of identifiers
// Here we use a conservative value that should work for most cases, and truncate names if needed
const IDENTIFIER_NAME_MAX_LENGTH = 50 - DELEGATE_AUX_RELATION_PREFIX.length;

// Datasource fields that only exist in ZModel but not in Prisma schema
const NON_PRISMA_DATASOURCE_FIELDS = ['defaultSchema'];

/**
 * Generates Prisma schema file
 */
export class PrismaSchemaGenerator {
    private readonly PRELUDE = `//////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE                                                                  //
// This file is automatically generated by ZenStack CLI and should not be manually updated. //
//////////////////////////////////////////////////////////////////////////////////////////////

`;

    // a mapping from full names to shortened names
    private shortNameMap = new Map<string, string>();

    constructor(private readonly zmodel: Model) {}

    async generate() {
        const prisma = new PrismaModel();

        for (const decl of this.zmodel.declarations) {
            switch (decl.$type) {
                case DataSource:
                    this.generateDataSource(prisma, decl as DataSource);
                    break;

                case Enum:
                    this.generateEnum(prisma, decl as Enum);
                    break;

                case DataModel:
                    this.generateModel(prisma, decl as DataModel);
                    break;

                case GeneratorDecl:
                    this.generateGenerator(prisma, decl as GeneratorDecl);
                    break;
            }
        }

        if (!this.zmodel.declarations.some(isGeneratorDecl)) {
            this.generateDefaultGenerator(prisma);
        }

        return this.PRELUDE + prisma.toString();
    }

    private generateDataSource(prisma: PrismaModel, dataSource: DataSource) {
        const fields: SimpleField[] = dataSource.fields
            .filter((f) => !NON_PRISMA_DATASOURCE_FIELDS.includes(f.name))
            .map((f) => ({
                name: f.name,
                text: this.configExprToText(f.value),
            }));
        prisma.addDataSource(dataSource.name, fields);
    }

    private configExprToText(expr: ConfigExpr) {
        if (isLiteralExpr(expr)) {
            return this.literalToText(expr);
        } else if (isInvocationExpr(expr)) {
            const fc = this.makeFunctionCall(expr);
            return fc.toString();
        } else {
            return this.configArrayToText(expr);
        }
    }

    private configArrayToText(expr: ConfigArrayExpr) {
        return (
            '[' +
            expr.items
                .map((item) => {
                    if (isLiteralExpr(item)) {
                        return this.literalToText(item);
                    } else {
                        return (
                            item.name +
                            (item.args.length > 0
                                ? '(' + item.args.map((arg) => this.configInvocationArgToText(arg)).join(', ') + ')'
                                : '')
                        );
                    }
                })
                .join(', ') +
            ']'
        );
    }

    private configInvocationArgToText(arg: ConfigInvocationArg) {
        return `${arg.name}: ${this.literalToText(arg.value)}`;
    }

    private literalToText(expr: LiteralExpr) {
        return JSON.stringify(expr.value);
    }

    private generateGenerator(prisma: PrismaModel, decl: GeneratorDecl) {
        prisma.addGenerator(
            decl.name,
            decl.fields.map((f) => ({
                name: f.name,
                text: this.configExprToText(f.value),
            })),
        );
    }

    private generateDefaultGenerator(prisma: PrismaModel) {
        const gen = prisma.addGenerator('client', [{ name: 'provider', text: '"prisma-client-js"' }]);
        const dataSource = this.zmodel.declarations.find(isDataSource);
        if (dataSource?.fields.some((f) => f.name === 'extensions')) {
            // enable "postgresqlExtensions" preview feature
            gen.fields.push({ name: 'previewFeatures', text: '["postgresqlExtensions"]' });
        }
    }

    private generateModel(prisma: PrismaModel, decl: DataModel) {
        const model = decl.isView ? prisma.addView(decl.name) : prisma.addModel(decl.name);
        const allFields = getAllFields(decl, true);
        for (const field of allFields) {
            if (ModelUtils.hasAttribute(field, '@computed')) {
                continue; // skip computed fields
            }
            // exclude non-id fields inherited from delegate
            if (ModelUtils.isIdField(field, decl) || !this.isInheritedFromDelegate(field, decl)) {
                this.generateModelField(model, field, decl);
            }
        }

        const allAttributes = getAllAttributes(decl).filter((attr) => this.isPrismaAttribute(attr));

        for (const attr of allAttributes) {
            this.generateContainerAttribute(model, attr);
        }

        if (
            this.datasourceHasSchemasSetting(decl.$container) &&
            !allAttributes.some((attr) => attr.decl.ref?.name === '@@schema')
        ) {
            // if the datasource declared `schemas` and no @@schema attribute is defined, add a default one
            model.addAttribute('@@schema', [
                new PrismaAttributeArg(
                    undefined,
                    new PrismaAttributeArgValue('String', this.getDefaultPostgresSchemaName(decl.$container)),
                ),
            ]);
        }

        // user defined comments pass-through
        decl.comments.forEach((c) => model.addComment(c));

        // generate relation fields on base models linking to concrete models
        this.generateDelegateRelationForBase(model, decl);

        // generate reverse relation fields on concrete models
        this.generateDelegateRelationForConcrete(model, decl);
    }

    private getDatasourceField(zmodel: Model, fieldName: string) {
        const dataSource = zmodel.declarations.find(isDataSource);
        return dataSource?.fields.find((f) => f.name === fieldName);
    }

    private datasourceHasSchemasSetting(zmodel: Model) {
        return !!this.getDatasourceField(zmodel, 'schemas');
    }

    private getDefaultPostgresSchemaName(zmodel: Model) {
        const defaultSchemaField = this.getDatasourceField(zmodel, 'defaultSchema');
        return getStringLiteral(defaultSchemaField?.value) ?? 'public';
    }

    private isPrismaAttribute(attr: DataModelAttribute | DataFieldAttribute) {
        if (!attr.decl.ref) {
            return false;
        }
        return attr.decl.ref.attributes.some((a) => a.decl.ref?.name === '@@@prisma');
    }

    private getUnsupportedFieldType(fieldType: DataFieldType) {
        if (fieldType.unsupported) {
            const value = getStringLiteral(fieldType.unsupported.value);
            if (value) {
                return `Unsupported("${value}")`;
            } else {
                return undefined;
            }
        } else {
            return undefined;
        }
    }

    private generateModelField(model: PrismaDataModel, field: DataField, contextModel: DataModel, addToFront = false) {
        let fieldType: string | undefined;

        if (field.type.type) {
            // intrinsic type
            fieldType = field.type.type;
        } else if (field.type.reference?.ref) {
            // model, enum, or type-def
            if (isTypeDef(field.type.reference.ref)) {
                fieldType = 'Json';
            } else {
                fieldType = field.type.reference.ref.name;
            }
        } else {
            // Unsupported type
            const unsupported = this.getUnsupportedFieldType(field.type);
            if (unsupported) {
                fieldType = unsupported;
            }
        }

        if (!fieldType) {
            throw new Error(`Field type is not resolved: ${field.$container.name}.${field.name}`);
        }

        const isArray =
            // typed-JSON fields should be translated to scalar Json type
            isTypeDef(field.type.reference?.ref) ? false : field.type.array;
        const type = new ModelFieldType(fieldType, isArray, field.type.optional);

        const attributes = field.attributes
            .filter((attr) => this.isPrismaAttribute(attr))
            // `@default` using `auth()` is handled outside Prisma
            .filter((attr) => !this.isDefaultWithAuthInvocation(attr))
            .filter(
                (attr) =>
                    // when building physical schema, exclude `@default` for id fields inherited from delegate base
                    !(
                        ModelUtils.isIdField(field, contextModel) &&
                        this.isInheritedFromDelegate(field, contextModel) &&
                        attr.decl.$refText === '@default'
                    ),
            )
            .map((attr) => this.makeFieldAttribute(attr));

        const docs = [...field.comments];
        const result = model.addField(field.name, type, attributes, docs, addToFront);
        return result;
    }

    private isDefaultWithAuthInvocation(attr: DataFieldAttribute) {
        if (attr.decl.ref?.name !== '@default') {
            return false;
        }

        const expr = attr.args[0]?.value;
        if (!expr) {
            return false;
        }

        return AstUtils.streamAst(expr).some(isAuthInvocation);
    }

    private isInheritedFromDelegate(field: DataField, contextModel: DataModel) {
        return field.$container !== contextModel && ModelUtils.isDelegateModel(field.$container);
    }

    private makeFieldAttribute(attr: DataFieldAttribute) {
        const attrName = attr.decl.ref!.name;
        return new PrismaFieldAttribute(
            attrName,
            attr.args.map((arg) => this.makeAttributeArg(arg)),
        );
    }

    private makeAttributeArg(arg: AttributeArg): PrismaAttributeArg {
        return new PrismaAttributeArg(arg.name, this.makeAttributeArgValue(arg.value));
    }

    private makeAttributeArgValue(node: Expression): PrismaAttributeArgValue {
        if (isLiteralExpr(node)) {
            const argType = match(node.$type)
                .with(StringLiteral, () => 'String' as const)
                .with(NumberLiteral, () => 'Number' as const)
                .with(BooleanLiteral, () => 'Boolean' as const)
                .exhaustive();
            return new PrismaAttributeArgValue(argType, node.value);
        } else if (isArrayExpr(node)) {
            return new PrismaAttributeArgValue(
                'Array',
                new Array(...node.items.map((item) => this.makeAttributeArgValue(item))),
            );
        } else if (isReferenceExpr(node)) {
            return new PrismaAttributeArgValue(
                'FieldReference',
                new PrismaFieldReference(
                    node.target.ref!.name,
                    node.args.map((arg) => new PrismaFieldReferenceArg(arg.name, this.exprToText(arg.value))),
                ),
            );
        } else if (isInvocationExpr(node)) {
            // invocation
            return new PrismaAttributeArgValue('FunctionCall', this.makeFunctionCall(node));
        } else {
            throw Error(`Unsupported attribute argument expression type: ${node.$type}`);
        }
    }

    private exprToText(expr: Expression) {
        return new ZModelCodeGenerator({ quote: 'double' }).generate(expr);
    }

    makeFunctionCall(node: InvocationExpr): PrismaFunctionCall {
        return new PrismaFunctionCall(
            node.function.ref!.name,
            node.args.map((arg) => {
                const val = match(arg.value)
                    .when(isStringLiteral, (v) => `"${v.value}"`)
                    .when(isLiteralExpr, (v) => v.value.toString())
                    .when(isNullExpr, () => 'null')
                    .otherwise(() => {
                        throw new Error('Function call argument must be literal or null');
                    });

                return new PrismaFunctionCallArg(val);
            }),
        );
    }

    private generateContainerAttribute(container: PrismaContainerDeclaration, attr: DataModelAttribute) {
        const attrName = attr.decl.ref!.name;
        container.attributes.push(
            new PrismaModelAttribute(
                attrName,
                attr.args.map((arg) => this.makeAttributeArg(arg)),
            ),
        );
    }

    private generateEnum(prisma: PrismaModel, decl: Enum) {
        const _enum = prisma.addEnum(decl.name);

        for (const field of decl.fields) {
            this.generateEnumField(_enum, field);
        }

        const allAttributes = decl.attributes.filter((attr) => this.isPrismaAttribute(attr));
        for (const attr of allAttributes) {
            this.generateContainerAttribute(_enum, attr);
        }

        if (
            this.datasourceHasSchemasSetting(decl.$container) &&
            !allAttributes.some((attr) => attr.decl.ref?.name === '@@schema')
        ) {
            // if the datasource declared `schemas` and no @@schema attribute is defined, add a default one
            _enum.addAttribute('@@schema', [
                new PrismaAttributeArg(
                    undefined,
                    new PrismaAttributeArgValue('String', this.getDefaultPostgresSchemaName(decl.$container)),
                ),
            ]);
        }

        // user defined comments pass-through
        decl.comments.forEach((c) => _enum.addComment(c));
    }

    private generateEnumField(_enum: PrismaEnum, field: EnumField) {
        const attributes = field.attributes
            .filter((attr) => this.isPrismaAttribute(attr))
            .map((attr) => this.makeFieldAttribute(attr));

        const docs = [...field.comments];
        _enum.addField(field.name, attributes, docs);
    }

    private generateDelegateRelationForBase(model: PrismaDataModel, decl: DataModel) {
        if (!isDelegateModel(decl)) {
            return;
        }

        // collect concrete models inheriting this model
        const concreteModels = this.getConcreteModels(decl);

        // generate an optional relation field in delegate base model to each concrete model
        concreteModels.forEach((concrete) => {
            const auxName = this.truncate(`${DELEGATE_AUX_RELATION_PREFIX}_${lowerCaseFirst(concrete.name)}`);
            model.addField(auxName, new ModelFieldType(concrete.name, false, true));
        });
    }

    private generateDelegateRelationForConcrete(model: PrismaDataModel, concreteDecl: DataModel) {
        // generate a relation field for each delegated base model
        const base = concreteDecl.baseModel?.ref;
        if (!base) {
            return;
        }

        const idFields = getIdFields(base);

        // add relation fields
        const relationField = this.truncate(`${DELEGATE_AUX_RELATION_PREFIX}_${lowerCaseFirst(base.name)}`);
        model.addField(relationField, base.name, [
            new PrismaFieldAttribute('@relation', [
                new PrismaAttributeArg(
                    'fields',
                    new AttributeArgValue(
                        'Array',
                        idFields.map(
                            (idField) => new AttributeArgValue('FieldReference', new PrismaFieldReference(idField)),
                        ),
                    ),
                ),
                new PrismaAttributeArg(
                    'references',
                    new AttributeArgValue(
                        'Array',
                        idFields.map(
                            (idField) => new AttributeArgValue('FieldReference', new PrismaFieldReference(idField)),
                        ),
                    ),
                ),
                new PrismaAttributeArg(
                    'onDelete',
                    new AttributeArgValue('FieldReference', new PrismaFieldReference('Cascade')),
                ),
                new PrismaAttributeArg(
                    'onUpdate',
                    new AttributeArgValue('FieldReference', new PrismaFieldReference('Cascade')),
                ),
            ]),
        ]);
    }

    private getConcreteModels(dataModel: DataModel): DataModel[] {
        if (!isDelegateModel(dataModel)) {
            return [];
        }
        return dataModel.$container.declarations.filter(
            (d): d is DataModel => isDataModel(d) && d !== dataModel && d.baseModel?.ref === dataModel,
        );
    }

    private truncate(name: string) {
        if (name.length <= IDENTIFIER_NAME_MAX_LENGTH) {
            return name;
        }

        const existing = this.shortNameMap.get(name);
        if (existing) {
            return existing;
        }

        const baseName = name.slice(0, IDENTIFIER_NAME_MAX_LENGTH);
        let index = 0;
        let shortName = `${baseName}_${index}`;

        while (true) {
            const conflict = Array.from(this.shortNameMap.values()).find((v) => v === shortName);
            if (!conflict) {
                this.shortNameMap.set(name, shortName);
                break;
            }

            // try next index
            index++;
            shortName = `${baseName}_${index}`;
        }

        return shortName;
    }
}
