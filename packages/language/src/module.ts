import { DocumentState, inject, URI, type DeepPartial, type Module } from 'langium';
import {
    createDefaultModule,
    createDefaultSharedModule,
    type DefaultSharedModuleContext,
    type LangiumServices,
    type LangiumSharedServices,
    type PartialLangiumServices,
} from 'langium/lsp';
import { NodeFileSystem } from 'langium/node';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import type { Model } from './ast';
import { ZModelGeneratedModule, ZModelGeneratedSharedModule, ZModelLanguageMetaData } from './generated/module';
import { getPluginDocuments } from './utils';
import { registerValidationChecks, ZModelValidator } from './validator';
import { ZModelCommentProvider } from './zmodel-comment-provider';
import { ZModelCompletionProvider } from './zmodel-completion-provider';
import { ZModelDefinitionProvider } from './zmodel-definition';
import { ZModelDocumentBuilder } from './zmodel-document-builder';
import { ZModelDocumentationProvider } from './zmodel-documentation-provider';
import { ZModelFormatter } from './zmodel-formatter';
import { ZModelLinker } from './zmodel-linker';
import { ZModelScopeComputation, ZModelScopeProvider } from './zmodel-scope';
import { ZModelSemanticTokenProvider } from './zmodel-semantic';
import { ZModelWorkspaceManager } from './zmodel-workspace-manager';
export { ZModelLanguageMetaData };

/**
 * Declaration of custom services - add your own service classes here.
 */
export type ZModelAddedServices = {
    validation: {
        ZModelValidator: ZModelValidator;
    };
};

/**
 * Union of Langium default services and your custom services - use this as constructor parameter
 * of custom service classes.
 */
export type ZModelServices = LangiumServices & ZModelAddedServices;

/**
 * Dependency injection module that overrides Langium default services and contributes the
 * declared custom services. The Langium defaults can be partially specified to override only
 * selected services, while the custom services must be fully specified.
 */
export const ZModelLanguageModule: Module<ZModelServices, PartialLangiumServices & ZModelAddedServices> = {
    references: {
        ScopeComputation: (services) => new ZModelScopeComputation(services),
        ScopeProvider: (services) => new ZModelScopeProvider(services),
        Linker: (services) => new ZModelLinker(services),
    },
    validation: {
        ZModelValidator: (services) => new ZModelValidator(services),
    },
    lsp: {
        Formatter: (services) => new ZModelFormatter(services),
        DefinitionProvider: (services) => new ZModelDefinitionProvider(services),
        CompletionProvider: (services) => new ZModelCompletionProvider(services),
        SemanticTokenProvider: (services) => new ZModelSemanticTokenProvider(services),
    },
    documentation: {
        CommentProvider: (services) => new ZModelCommentProvider(services),
        DocumentationProvider: (services) => new ZModelDocumentationProvider(services),
    },
};

export type ZModelSharedServices = LangiumSharedServices;

export const ZModelSharedModule: Module<ZModelSharedServices, DeepPartial<ZModelSharedServices>> = {
    workspace: {
        DocumentBuilder: (services) => new ZModelDocumentBuilder(services),
        WorkspaceManager: (services) => new ZModelWorkspaceManager(services),
    },
};

/**
 * Create the full set of services required by Langium.
 *
 * First inject the shared services by merging two modules:
 *  - Langium default shared services
 *  - Services generated by langium-cli
 *
 * Then inject the language-specific services by merging three modules:
 *  - Langium default language-specific services
 *  - Services generated by langium-cli
 *  - Services specified in this file
 *
 * @param context Optional module context with the LSP connection
 * @returns An object wrapping the shared services and the language-specific services
 */
export function createZModelLanguageServices(
    context: DefaultSharedModuleContext,
    logToConsole = false,
): {
    shared: LangiumSharedServices;
    ZModelLanguage: ZModelServices;
} {
    const shared = inject(createDefaultSharedModule(context), ZModelGeneratedSharedModule, ZModelSharedModule);
    const ZModelLanguage = inject(createDefaultModule({ shared }), ZModelGeneratedModule, ZModelLanguageModule);
    shared.ServiceRegistry.register(ZModelLanguage);
    registerValidationChecks(ZModelLanguage);
    if (!context.connection) {
        // We don't run inside a language server
        // Therefore, initialize the configuration provider instantly
        shared.workspace.ConfigurationProvider.initialized({});
    }

    // when documents reach Parsed state, inspect plugin declarations and load corresponding
    // plugin zmodel docs
    // Note we must use `onBuildPhase` instead of `onDocumentPhase` here because the latter is
    // not called when not running inside a language server.
    shared.workspace.DocumentBuilder.onBuildPhase(DocumentState.Parsed, async (documents) => {
        for (const doc of documents) {
            if (doc.parseResult.lexerErrors.length > 0 || doc.parseResult.parserErrors.length > 0) {
                // balk if there are lexer or parser errors
                continue;
            }

            if (doc.uri.scheme !== 'file') {
                continue;
            }

            const schemaPath = fileURLToPath(doc.uri.toString());
            const pluginSchemas = getPluginDocuments(doc.parseResult.value as Model, schemaPath);

            // ensure plugin docs are loaded
            for (const plugin of pluginSchemas) {
                const pluginDocUri = URI.file(path.resolve(plugin));
                let pluginDoc = shared.workspace.LangiumDocuments.getDocument(pluginDocUri);
                if (!pluginDoc) {
                    pluginDoc = await shared.workspace.LangiumDocuments.getOrCreateDocument(pluginDocUri);
                    if (pluginDoc) {
                        // add to indexer so the plugin model's definitions are globally visible
                        shared.workspace.IndexManager.updateContent(pluginDoc);
                        if (logToConsole) {
                            console.log(`Loaded plugin model: ${plugin}`);
                        }
                    }
                }
            }
        }
    });

    return { shared, ZModelLanguage };
}

// TODO: proper logging system
export function createZModelServices(logToConsole = false) {
    return createZModelLanguageServices(NodeFileSystem, logToConsole);
}
